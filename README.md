# Описание PostgreSQL-кластера с горячим резервированием
Этот текст описывает кластер PostgreSQL, реализованный с помощью Docker и состоящий из трёх контейнеров:

* Master: Основной сервер PostgreSQL.
* Slave: Резервный сервер, который синхронизируется с Master.
* Arbiter: Сервер, используемый для определения работоспособности Master и Slave.

# Скрипт-агент:
В каждый контейнер запускается Python-скрипт, который выполняет следующие действия:

* Проверка связи: Регулярно проверяет связь между Slave и Master, а также между Arbiter и Master.
* Промоут Slave: Если Slave теряет связь с Master и получает подтверждение потери связи от Arbiter, он промоутится до Master. Промоут осуществляется путём создания триггер-файла "/tmp/promote_me".
* Блокировка Master: Если Master теряет связь с Slave и Arbiter, он блокирует все входящие подключения через iptables.

# Запуск и тестирование:
* Запуск кластера: docker compose up
* Тестирование: 
    * Запустить скрипт writer.py на хосте для имитации записи данных в базу.
    * Тест №1: Остановить Slave (docker compose stop pg-slave) во время работы writer.py.
    * Тест №2: Остановить Master (docker compose stop pg-master) во время работы writer.py.

# Результаты тестирования:
* Тест №1 (Slave):
    * synchronous_commit = off: потери данных отсутствуют.
    * synchronous_commit = remote_apply: потери данных отсутствуют.
* Тест №2 (Master):
    * synchronous_commit = off: потеряно 24 записи.
    * synchronous_commit = remote_apply: потери данных отсутствуют.

# Вывод:
Тесты показывают, что при использовании synchronous_commit = remote_apply потери данных отсутствуют, даже если Slave или Master недоступны. При synchronous_commit = off потери данных возможны, если Master становится недоступным.

# Важно отметить:

* synchronous_commit = remote_apply обеспечивает синхронную запись изменений на Master и Slave.
*  Кластер может быть полезен для различных приложений, где требуется высокая доступность, например, для онлайн-магазинов или веб-сервисов.
*  Схема настройки кластера и сценарии тестирования могут быть адаптированы в соответствии с конкретными требованиями приложения.